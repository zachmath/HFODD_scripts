#!/usr/bin/python

## for LaTeX in the .ps
import matplotlib
matplotlib.use ('PS')
from matplotlib import rc
matplotlib.rcParams['text.latex.preamble']=[r"\usepackage{amsmath}"]
# to have ascii hyphen minus signs (shorter than the official unicode)
matplotlib.rcParams['text.latex.unicode']=False
matplotlib.rc ('font',**{'family':'serif','serif':['Times'] , 'size':20})

from matplotlib.pyplot import figure , axes , plot , xlabel , ylabel , title , grid , savefig , show
import numpy as np
from pylab import *

import matplotlib.pyplot as plt
from matplotlib.pyplot import axhline


infile = raw_input("\n Please list the name of the input file containing the density information (typically densi_[something].out): \n Columns should be ordered x, y, z, rho_p, rho_n, rho_tot. \n")

# get data
data = np.genfromtxt (infile) # Columns are: x, y, z, rho_p, rho_n, rho_tot
x0 = data[:,0]
y0 = data[:,1]
z0 = data[:,5]
z1 = data[:,2]

# Take a single cross-sectional slice of the total 3D density
zslice = np.min(abs(z1))
x0 = x0[(z1 == zslice)]
y0 = y0[(z1 == zslice)]
z0 = z0[(z1 == zslice)]

# basis grid for the interpolation
xi = np.linspace (min (x0) , max (x0))
yi = np.linspace (min (y0) , max (y0))

# interpolate data
X0, Y0 = np.meshgrid (xi , yi)
Z0 = griddata (x0 , y0 , z0 , xi , yi)

# get Z max and min to set the plot
maxZ0 = Z0.max ();
minZ0 = Z0.min ();
print maxZ0
print minZ0

# APS required dpi, figsize can change
fig = plt.figure (figsize = (6.0 , 6.0) , dpi = 1200)

# add a plot on the figure
ax = fig.add_subplot (111)


# set labels
ax.set_xlabel (r"$ x (\rm{b}) $" , fontsize=20)
ax.set_ylabel (r"$ y (\rm{b}) $" , fontsize=20)

# set ticks (min, max, step) gives: [min , min+step , ... , max-step]
tab_range = np.arange (round(X0.min()), round(X0.max()), 3.0)
#tab_range = np.arange (0.0, 300.0, 100.0)
ax.xaxis.set_ticks (tab_range)
tab_range = np.arange (round(Y0.min()), round(Y0.max()), 3.0)
#tab_range = np.arange (0.0, 35.0, 10.0)
ax.yaxis.set_ticks (tab_range)


origin = 'lower'
CS0 = plt.contourf (X0 , Y0 , Z0 , 100 , origin=origin , vmin=minZ0 , vmax=maxZ0, cmap=plt.cm.gnuplot)


############
# colorbar #
############
# compress the figure to make some room for the colorbar
fig.subplots_adjust (right=0.88)

# set the colorbar position and size
# [distance to the z axis , height from the bottom , width of the bar , length of the bar]
cbar_ax = fig.add_axes ([0.9 , 0.1 , 0.04 , 0.8])

# ticks along the colorbar
step = 5
decimal_number = 20#-1
v = np.linspace (round (minZ0 , decimal_number) , round (maxZ0 + (maxZ0-minZ0)/step , decimal_number) , step , endpoint=True).tolist ()
v = [round (elem , decimal_number) for elem in v] # warning, these are positions of ticks, the "round" function can lead to irregular spacings

#wait = raw_input("PRESS ENTER TO CONTINUE.")

# plot the colorbar
cb = plt.colorbar (CS0 , cax=cbar_ax , ticks=v , norm=matplotlib.colors.Normalize (vmin=minZ0 , vmax=maxZ0))


# to get scientific notation (conflict with APS font)
matplotlib.rcParams['axes.unicode_minus'] = False
cb.formatter.set_powerlimits ((0 , 0))
cb.update_ticks ()


# hide the exponent generated by the scientific notation
# conflict with internal LaTeX routines
# look at the maxZ0 which is printed at the execution, look at the colorbar ticks and deduce the exponent
# then add it in the label definition (APS recommended: "x (10^2 fm)")
cb.ax.get_yaxis ().get_offset_text ().set_visible (False)
############




# to call external LaTeX libraries for dealing with latex command not included in python
# will produce conflicts if called before
matplotlib.rc ('text', usetex=True)


# to add some text on the graph
# not tested
#ax.text (9 , 0 , 0 , "toto" , color='red')
#ax.annotate(r"$ \boldsymbol{ {1/2}^{+} } $" , xy=(6.3 , 6.5) , color='white' , ha='center' , fontsize=23)


# save in ps format, cannot be donne directly in pdf and eps has no bounding box
# follow the instruction below to get a pdf with bounding box
fig.savefig ('view3.ps')
# in the terminal:
# ps2eps -f test.ps ; epstopdf test.eps



################################################
# Now repeat the calculation for another view ##
################################################


# get data
y0 = data[:,0]
x0 = data[:,2]
z0 = data[:,5]
z1 = data[:,1]

# Take a single cross-sectional slice of the total 3D density
zslice = np.min(abs(z1))
x0 = x0[(z1 == zslice)]
y0 = y0[(z1 == zslice)]
z0 = z0[(z1 == zslice)]

minx = min(min(x0),min(y0))
maxx = max(max(x0),max(y0))

xi = np.linspace (minx , maxx)
yi = np.linspace (minx , maxx)

X0, Y0 = np.meshgrid (xi , yi)
Z0 = griddata (x0 , y0 , z0 , xi , yi)
maxZ0 = Z0.max ();
minZ0 = Z0.min ();
print maxZ0
print minZ0
fig = plt.figure (figsize = (6.0 , 6.0) , dpi = 1200)
ax = fig.add_subplot (111)
ax.set_xlabel (r"$ z (\rm{b}) $" , fontsize=20)
ax.set_ylabel (r"$ x (\rm{b}) $" , fontsize=20)
rangemax = max(round(X0.max()),round(Y0.max()))
rangemin = min(round(X0.min()),round(Y0.min()))
tab_range = np.arange (rangemin, rangemax, 5.0)
ax.xaxis.set_ticks (tab_range)
ax.yaxis.set_ticks (tab_range)
origin = 'lower'
CS0 = plt.contourf (X0 , Y0 , Z0 , 100 , origin=origin , vmin=minZ0 , vmax=maxZ0, cmap=plt.cm.gnuplot)
fig.subplots_adjust (right=0.88)
cbar_ax = fig.add_axes ([0.9 , 0.1 , 0.04 , 0.8])
step = 5
decimal_number = 20#-1
v = np.linspace (round (minZ0 , decimal_number) , round (maxZ0 + (maxZ0-minZ0)/step , decimal_number) , step , endpoint=True).tolist ()
v = [round (elem , decimal_number) for elem in v]
cb = plt.colorbar (CS0 , cax=cbar_ax , ticks=v , norm=matplotlib.colors.Normalize (vmin=minZ0 , vmax=maxZ0))
matplotlib.rcParams['axes.unicode_minus'] = False
cb.formatter.set_powerlimits ((0 , 0))
cb.update_ticks ()
cb.ax.get_yaxis ().get_offset_text ().set_visible (False)
matplotlib.rc ('text', usetex=True)
fig.savefig ('view1.ps')



################################################
# Now repeat the calculation for another view ##
################################################


# Take a single cross-sectional slice of the total 3D density
y0 = data[:,1]
x0 = data[:,2]
z0 = data[:,5]
z1 = data[:,0]

# Take a single cross-sectional slice of the total 3D density
zslice = np.min(abs(z1))
x0 = x0[(z1 == zslice)]
y0 = y0[(z1 == zslice)]
z0 = z0[(z1 == zslice)]

minx = min(min(x0),min(y0))
maxx = max(max(x0),max(y0))

xi = np.linspace (minx , maxx)
yi = np.linspace (minx , maxx)

X0, Y0 = np.meshgrid (xi , yi)
Z0 = griddata (x0 , y0 , z0 , xi , yi)
maxZ0 = Z0.max ();
minZ0 = Z0.min ();
print maxZ0
print minZ0
fig = plt.figure (figsize = (6.0 , 6.0) , dpi = 1200)
ax = fig.add_subplot (111)
ax.set_xlabel (r"$ z (\rm{b}) $" , fontsize=20)
ax.set_ylabel (r"$ y (\rm{b}) $" , fontsize=20)
rangemax = max(round(X0.max()),round(Y0.max()))
rangemin = min(round(X0.min()),round(Y0.min()))
tab_range = np.arange (rangemin, rangemax, 5.0)
ax.xaxis.set_ticks (tab_range)
ax.yaxis.set_ticks (tab_range)
origin = 'lower'
CS0 = plt.contourf (X0 , Y0 , Z0 , 100 , origin=origin , vmin=minZ0 , vmax=maxZ0, cmap=plt.cm.gnuplot)
fig.subplots_adjust (right=0.88)
cbar_ax = fig.add_axes ([0.9 , 0.1 , 0.04 , 0.8])
step = 5
decimal_number = 20#-1
v = np.linspace (round (minZ0 , decimal_number) , round (maxZ0 + (maxZ0-minZ0)/step , decimal_number) , step , endpoint=True).tolist ()
v = [round (elem , decimal_number) for elem in v]
cb = plt.colorbar (CS0 , cax=cbar_ax , ticks=v , norm=matplotlib.colors.Normalize (vmin=minZ0 , vmax=maxZ0))
matplotlib.rcParams['axes.unicode_minus'] = False
cb.formatter.set_powerlimits ((0 , 0))
cb.update_ticks ()
cb.ax.get_yaxis ().get_offset_text ().set_visible (False)
matplotlib.rc ('text', usetex=True)
fig.savefig ('view2.ps')

